# Operating System

## 📖 목록

- [Process, Thread](#osi-7-layer)
- [Interrupt](#interrupt)
- [PCB, Context Switching](#pcb-context-switching)
- [Deadlock](#deadlock)
- [Semaphore, Mutex](#semaphore-mutex)
- [Paging, Segmentation](#paging-segmentation)

## Process, Thread

- Process
  - 프로그램 메모리 상에서 실행 중인 작업
  - Code, Data, Heap, Stack으로 구성된 독립적인 메모리 영역을 할당받는다.
    - Code: 코드 자체를 구성하는 메모리 영역
    - Data: 전역변수, 정적변수, 배열 등
    - Heap: 동적 할당 시 사용(new(), malloc() 등)
    - Stack: 지역변수, 매개변수, 리턴 값(임시 메모리 영역)
  - 각 프로세스는 자신만의 고유 공간과 자원을 할당받아 사용하므로 다른 프로세스는 접근할 수 없다.
    - 다른 프로세스에 접근하려면 IPC(Inter Process Communication)를 사용해야 한다.
      - IPC
        - Inter-Process Communication의 약자로, 프로세스에 문제가 생겨 다른 프로세스의 스택 영역을 침범하는 일을 막기 위해 생겼다. 프로세스는 IPC를 통하여 다른 프로세스에 데이터를 송신하거나 다른 프로세스로부터 데이터를 수신할 수 있다. 즉, IPC는 영문 그대로 프로세스 간 통신을 뜻한다.
- Thread
  - 프로세스 안에서 실행되는 여러 흐름 단위
  - 프로세스가 생성될 때 기본적으로 하나의 스레드가 같이 생성된다.
  - Process 내에서 Code, Data, Heap 영역은 공유하지만 Stack은 개별적으로 할당 받는다.
- Java Thread
  - 일반 스레드와 차이가 없으며, JVM이 운영체제 역할을 한다.
  - Java에는 프로세스가 존재하지 않으며 Java Thread는 JVM에 스케줄 되는 실행 단위 코드 블록이다.
- Multi Process
  - 하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 병렬적으로 작업을 수행한다.
  - 장점
    - 안정성(프로세스에 문제가 발생하면 그 프로세스만 죽는 것 이상으로 다른 영향이 확산하지 않는다.)
  - 단점
    - Context Switching으로 인한 성능 저하
      - Context Switching
        - 프로세스의 상태 정보를 저장하고 복원하는 일련의 과정이다.
        - 동작 중인 프로세스가 대기하면서 해당 프로세스의 상태(Context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 과정이다.
        - 프로세스는 각 독립된 메모리 영역을 할당받아 사용되므로, 캐시 메모리 초기화와 같은 무거운 작업이 진행되었을 때 오버헤드가 발생할 문제가 존재한다.
- Multi Thread
  - 하나의 응용 프로그램에서 여러 스레드를 구성하여 각 스레드가 하나의 작업을 처리하는 것이다.
  - 장점
    - 독립적인 프로세스에 비해 공유 메모리만큼의 시간, 자원 손실이 감소하고 전역 변수와 정적 변수에 대한 자료 공유가 가능하다.
  - 단점
    - 안정성 문제(하나의 스레드가 데이터 공간을 망가뜨리면 모든 스레드가 작동 불능 상태(공유 메모리를 갖기 때문이다.))
      - Critical Section 기법을 통해 대비
        - Critical Section 기법
          - 하나의 스레드가 공유 데이터 값을 변경하는 시점에 다른 스레드가 그 값을 읽으려할 때 발생하는 문제를 해결하기 위한 동기화 과정
- 멀티프로세스 대신 멀티스레드를 사용한다.
  - 자원의 효율성
  - 처리 비용 감소 및 응답 시간 단축

## Interrupt

- 프로그램을 실행하는 도중에 예기치 않은 상황이 발생할 경우 현재 실행 중인 작업을 즉시 중단하고, 발생한 상황에 대한 우선 처리가 필요함을 CPU에 알리는 것
- 외부 인터럽트(하드웨어 인터럽트)
  - 입출력 장치, 타이밍 장치, 전원 등 외부적인 요인에 의해서 발생하는 인터럽트
- 내부 인터럽트(소프트웨어 인터럽트)
  - 잘못된 명령이나 데이터를 사용할 때 발생하는 인터럽트

## PCB, Context Switching

- Process Control Block
  - Process Metadata를 저장해놓는 곳으로 한 PCB에는 한 프로세스의 정보가 담긴다.
    - Process Metadata
      - 프로세스의 특징을 담고 있다. (CPU는 각 프로세스가 누구인지 알아야 관리 가능하기 때문이다.)
  - CPU에서는 프로세스의 상태에 따라 교체 작업이 이루어지는데(interrupt가 발생해서 할당받은 프로세스가 waiting 상태가 되고 다른 프로세스를 running으로 바꿔 올릴 때), 다시 수행할 대기 중인 프로세스에 관한 저장 값을 PCB에 저장해서 사용한다.
  - PCB는 Linked-List 방식으로 관리되며, 프로세스가 생성되면 PCB가 생성되고 프로세스 완료 시 제거된다.
  - 수행 중인 프로세스가 변경될 때, CPU의 레지스터 정보가 변경되는 것을 Context Switching이라 한다.
- Context Switching
  - CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에 읽어 레지스터에 적재하는 과정이다.
  - Overhead
    - CPU가 놀지 않도록 하며, 계속 프로세스를 수행하여 다른 프로세스로 Context Switching 하는 것이다.

## Deadlock

- 두 개 이상의 프로세스나 스레드가 서로 자원을 얻지 못해서 다음 처리를 하지 못하는 상태로 무한히 다음 자원을 기다리게 되는 상태이다.
- 시스템적으로 한정된 자원을 여러 곳에서 사용하려고 할 때 발생한다.
- 발생 조건
  - 상호 배제(Mutual exclusion)
    - 자원은 한 번에 한 프로세스만 사용할 수 있다.
  - 점유 대기(Hold and wait)
    - 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당되어 사용하고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 존재해야 한다.
  - 비선점(No preemption)
    - 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없다.
  - 순환 대기(Circular wait)
    - 프로세스의 집합에서 순환 형태로 자원을 대기하고 있어야 한다.
- 예방/회피
  - 예방(prevention)
    - 교착 상태 발생 조건 중 하나를 제거하면서 해결하는 방법으로 자원 낭비가 매우 심하다.
      - 상호배제 부정: 여러 프로세스가 공유 자원 사용한다.
      - 점유대기 부정: 프로세스 실행 전 모든 자원을 할당한다.
      - 비선점 부정: 자원 점유 중인 프로세스가 다른 자원을 요구할 때 가진 자원 반납한다.
      - 순환대기 부정: 자원에 고유번호 할당 후 순서대로 자원 요구한다.
  - 회피(avoidance)
    - 교착 상태 발생 시 피해 나가는 방법이다.
      - 은행원 알고리즘(Banker's Algorithm)
        - 은행에서 모든 고객의 요구가 충족되도록 현금을 할당하는 데서 유래했다.
        - 프로세스가 자원을 요구할 때, 시스템은 자원을 할당한 후에도 안정 상태로 남아있게 되는지 사전에 검사하여 교착 상태를 회피한다.
        - 안정 상태면 자원 할당, 아니면 다른 프로세스들이 자원 해지까지 대기한다.
- 탐지/회복
  - 탐지(Detection)
    - 자원 할당 그래프를 통해 교착 상태를 탐지한다.
    - 자원 요청 시, 탐지 알고리즘을 실행시켜 그에 대한 오버헤드 발생한다.
  - 회복(Recovery)
    - 교착 상태 일으킨 프로세스를 종료하거나, 할당된 자원을 해제시켜 회복시키는 방법이다.
    - 프로세스 종료 방법
      - 교착 상태의 프로세스를 모두 중지한다.
      - 교착 상태가 제거될 때까지 하나씩 프로세스 중지한다.
    - 자원 선점 방법
      - 교착 상태의 프로세스가 점유하고 있는 자원을 선점해 다른 프로세스에 할당한다. (해당 프로세스 일시 정지시킨다.)
      - 우선순위가 낮은 프로세스나 수행 횟수 적은 프로세스 위주로 프로세스 자원 선점한다.

## Semaphore, Mutex

- Semaphore
  - 멀티프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법이다.
  - Critical Section(임계 구역)
    - 여러 프로세스가 데이터를 공유하며 수행될 때, 각 프로세스에서 공유 데이터에 접근하는 프로그램 코드 부분이다.
    - 공유 데이터를 여러 `프로세스`가 동시에 접근할 때 잘못된 결과를 만들 수 있기 때문에, 한 프로세스가 임계 구역을 수행할 때는 다른 프로세스가 접근하지 못하도록 해야 한다.
- Mutex
  - 임계 구역을 가진 `스레드`들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술(상호 배제(`Mut`ual `Ex`clusion)의 약자)로 상태가 0, 1이기 때문에 이진 세마포어라고도 불린다.
  - lock
    - 현재 임계 구역에 들어갈 권한을 얻어온다. (다른 프로세스/스레드가 임계 구역 수행 중이면 종료할 때까지 대기한다.)
  - unlock
    - 현재 임계 구역을 모두 사용했음을 알린다. (대기 중인 다른 프로세스/스레드가 임계 구역에 진입할 수 있다.)

## Paging, Segmentation

- 다중 프로그래밍 시스템에 여러 프로세스를 수용하기 위해 주기억장치를 동적 분할하는 메모리 관리 작업이 필요하므로 페이징 혹은 세그먼테이션 기법을 사용한다.
- 메모리 관리 기법
  - 연속 메모리 관리
    - 프로그램 전체가 하나의 커다란 공간에 연속적으로 할당되어야 한다.
    - 고정 분할 기법: 주기억장치가 고정된 파티션으로 분할한다. (내부 단편화 발생)
    - 동적 분할 기법: 파티션들이 동적 생성되며 자신의 크기와 같은 파티션에 적재한다. (외부 단편화 발생)
  - 불연속 메모리 관리
    - 프로그램의 일부가 서로 다른 주소 공간에 할당될 수 있는 기법이다.
    - 페이지: 고정 사이즈의 작은 프로세스 조각
    - 프레임: 페이지 크기와 같은 주기억장치 메모리 조각
    - 단편화: 기억 장치의 빈 공간 or 자료가 여러 조각으로 나뉘는 현상
    - 세그먼트: 서로 다른 크기를 가진 논리적 블록이 연속적 공간에 배치되는 것
    - 고정 크기: 페이징(Paging)
    - 가변 크기: 세그먼테이션(Segmentation)
  - 단순 페이징
    - 각 프로세스는 프레임들과 같은 길이를 가진 균등 페이지로 나뉜다.
    - 외부 단편화 X
    - 소량의 내부 단편화 존재
  - 단순 세그먼테이션
    - 각 프로세스는 여러 세그먼트로 나뉜다.
    - 내부 단편화 X, 메모리 사용 효율 개선, 동적 분할을 통한 오버헤드 감소
    - 외부 단편화 존재
  - 가상 메모리 페이징
    - 단순 페이징과 비교해 프로세스 페이지 전부를 로드시킬 필요 X
    - 필요한 페이지가 있으면 나중에 자동으로 불러들여진다.
    - 외부 단편화 X
    - 복잡한 메모리 관리로 오버헤드 발생
  - 가상 메모리 세그먼테이션
    - 필요하지 않은 세그먼트들은 로드되지 않는다.
    - 필요한 세그먼트 있을때 나중에 자동으로 불러들여진다.
    - 내부 단편화 X
    - 복잡한 메모리 관리로 오버헤드 발생
