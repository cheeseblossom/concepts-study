# Web

## 📖 목록

- [URL, URI, URN](#url-uri-urn)
- [브라우저 동작 방법](#브라우저-동작-방법)
- [API key, OAuth2, JWT](#api-key-oauth2-jwt)
- [HTTP Request Method](#http-request-method)
- [Cookie, Session](#cookie-session)
- [Web Server Configuration](#web-server-configuration)
  - [keep-alive](#keep-alive)
- [Web Server, WAS](#web-server-was)
- [CSRF, XSS](#csrf-xss)
- [AJP](#ajp)
- [REST API](./rest.md)

## URL, URI, URN

- URI(Uniform Resource Identifier)
  - Uniform: 리소스를 식별하는 통일된 방식
  - Resource: URI로 식별할 수 있는 모든 자원(웹 브라우저 파일 및 그 외의 모든 리소스)
  - Identifier: 다른 항목과 구분하기 위해 필요한 정보
  - 인터넷상의 `리소스 자원 자체를 식별`하는 고유한 문자열 시퀀스
- URL(Uniform Resource Locator)
  - 네트워크상에서 자원의 위치를 나타내기 위한 규약으로 `자원 식별자와 위치`를 동시에 나타낸다.
  - scheme, host, port, path, query, fragment로 구성된다.
    - https://test.com:3000/search?q=js#doc
    - scheme: file://, http://, https://
    - host: test.com
    - port: :80, :443, :3000
    - path: /search
    - query: ?q=js
    - fragment: #doc
- URN(Uniform Resource Name)

  - 자원의 위치, 프로토콜, 호스트 등과는 상관없이 각 자원에 이름을 부여한 것으로 URL이 어떤 서버에 있는 웹 문서를 나타내지만, URN은 웹 문서의 물리적인 `위치와 상관없이 웹 문서 자체`(위치 상관 없이 이름만으로 식별 가능)를 나타낸다.

- URI=식별자, URL=식별자+위치
- URL은 URI의 일종이다. (URI가 더 포괄적인 개념)

## 브라우저 동작 방법

- 브라우저 기본 구조

  - ![image](/images/web/browser.png)
  - 사용자 인터페이스: 주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다.
  - 브라우저 엔진: 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어한다.
  - 렌더링 엔진: 요청한 콘텐츠를 표시. 예를 들어 HTML을 요청하면 HTML과 CSS를 파싱하여 화면에 표시한다.
  - 통신: HTTP 요청과 같은 네트워크 호출에 사용된다. 이것은 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행된다.
  - UI 백엔드: 콤보 박스와 창 같은 기본적인 장치를 그린다. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, OS 사용자 인터페이스 체계를 사용한다.
  - 자바스크립트 해석기: 자바스크립트 코드를 해석하고 실행한다.
  - 자료 저장소: 이 부분은 자료를 저장하는 계층이다. 쿠키를 저장하는 것과 같이 모든 종류의 자원을 하드 디스크에 저장할 필요가 있다. HTML5 명세에는 브라우저가 지원하는 '웹 데이터베이스'가 정의되어 있다.

- 렌더링
  - 렌더링 엔진은 요청받은 내용을 브라우저 화면에 표시하는 역할을 한다.
  - 기본적으로 html, xml, 이미지를 표시할 수 있으며 추가 플러그인이나 브라우저 확장 기능을 통해 pdf 등 다른 유형도 표시할 수 있다.
  - 렌더링 동작 과정
    1. html 문서를 파싱한다.
    2. 콘텐츠 트리 내부에서 태그를 모두 DOM 노드로 변환한다.
    3. 외부 css 파일과 함께 포함된 스타일 요소를 파싱한다.
    4. 이 스타일 정보와 html 표시 규칙은 렌더 트리라고 부르는 또 다른 트리를 생성한다. (이렇게 생성된 렌더 트리는 정해진 순서대로 화면에 표시되는데, 생성 과정이 끝났을 때 배치가 진행되면서 노드가 화면의 정확한 위치에 표시되는 것을 의미한다.)
    5. UI 백엔드에서 렌더 트리의 각 노드를 가로지으며 형상을 만드는 그리기 과정이 진행된다. (이러한 과정이 점진적으로 진행되며, 렌더링 엔진은 좀 더 빠르게 사용자에게 제공하기 위해 모든 html을 파싱할 때까지 기다리지 않고 배치와 그리기 과정을 시작한다.)
    - 전송을 받고 기다리는 동시에 받은 내용을 먼저 화면에 보여준다.

1. 주소창에 url을 입력하고 Enter를 누르면, 서버에 요청이 전송된다.
2. 해당 페이지에 존재하는 여러 자원들(text, image 등)이 보내진다.
3. 이제 브라우저는 해당 자원이 담긴 html과 스타일이 담긴 css를 W3C 명세에 따라 해석할 것이다.
   - 이 역할을 하는 것이 '렌더링 엔진'이다.
4. 렌더링 엔진은 우선 html 파싱 과정을 시작한다. html 파서가 문서에 존재하는 어휘와 구문을 분석하면서 DOM 트리를 구축한다.
5. 다음엔 css 파싱 과정 시작한다. css 파서가 모든 css 정보를 스타일 구조체로 생성한다.
   - 이 2가지를 연결시켜 렌더 트리를 만든다. 렌더 트리를 통해 문서가 시각적 요소를 포함한 형태로 구성된 상태이다.
6. 화면에 배치를 시작하고, UI 백엔드가 노드를 돌며 형상을 그린다.
   - 이때, 빠른 브라우저 화면 표시를 위해 '배치와 그리는 과정'은 페이지 정보를 모두 받고 한꺼번에 진행되지 않는다. 자원을 전송받으면 기다리는 동시에 일부분 먼저 진행하고 화면에 표시한다.

## API key, OAuth2, JWT

- API Key
  - 전통적인 인증/인가 방법
  - 클라이언트는 리소스 접근을 위해서 API key와 함께 요청을 보내고 서버는 API key를 DB의 인증저장소의 것과 비교해서 클라이언트에게 권한을 주는 방식이다.
  - 인증 서버를 구축하는 개발자, API를 사용하는 개발자 모두 매우 간단하게 개발을 진행할 수 있다.
  - 하지만 API key는 통신 구간에서 유출될 것을 대비해야 할 것이며, 주기적인 업데이트가 필요할 수 있다.
  - 또한 ACL, 가령 허가된 IP 관리 등을 하지 않으면 보안 문제로 이어질 수 있다.
  - 허가된 IP 관리는 요즘 대세인 클라우드에 적합하지 않다. (Auto scaling에 부적합)
- OAuth2
  - Open Authentication 2.0은 HTTP 기반의 인증을 위한 업계 표준 프로토콜이다.
  - 리소스의 소유자를 대신하여 리소스에 대한 접근을 제어할 수 있다.
  - Resource Owner: 접근에 인증이 필요한 리소스에 대해서 접근하고자 하는 Entity로 유저일수도, 서버일수도 있다. `리소스를 사용하고자 요청을 보내는 주체`
  - Resource Server: 리소스가 존재하는 서버로 리소스를 가지고 있고 해당 리소스에 접근 권한이 있는 사용자에게만 접근할 수 있도록 허용한다.
  - Authentication Server: 리소스에 대한 접근 권한 등을 관리하는 서버로 리소스 서버에 리소스 소유자가 클라이언트를 이용해 접근할 수 있도록 Access Token을 만들어 주며, Grant Type/인증 정보를 관리한다.
  - Client: 리소스 소유자를 대신하여 리소스 서버에 요청하는 애플리케이션으로 웹, 모바일 앱, 데스크 탑 애플리케이션 등이 해당한다.
- JWT
  - JSON Web Token은 웹에서 사용되는 JSON 형식의 토큰에 대한 표준 규격이다.
  - 기존 Cookie, Session의 단점을 극복하고자 나온 방법이다.
  - 주로 사용자의 인증(authentication) 또는 인가(authorization) 정보를 서버와 클라이언트 간에 안전하게 주고받기 위해서 사용한다.
  - header, payload, signature로 구성되며 각 구역이 `.`으로 구분된다.
  - header에는 토큰 유형과 서명 알고리즘이 명시되며, payload에는 사용자의 인가/인증 정보가 담긴다. signature에는 header와 payload가 비밀키로 서명되어 저장된다.
  - 토큰 자체에 사용자 정보가 저장되어 있기 때문에 서버는 토큰 검증만 하면 된다는 장점이 있다. 즉, 쿠키와 세션을 사용할 때는 사용자 데이터를 매번 조회해야 하지만 JWT는 그럴 필요가 없다. 또한, 쿠키를 사용하지 않기 때문에 CORS 문제로부터 자유로워진다.
  - 현재 로그인된 모든 기기를 나열하거나 특정 기기에서 로그아웃을 허용하는 등의 기능 구현이 어렵다는 단점이 있다. (이를 위해서는 서버 단에 사용자 세션이 저장되어야 하기 때문) 또한, 서명된 경우 JWT 서버에서만 유효성을 검증할 수 있지만 누구나 열람이 가능하므로 민감 정보를 다루기에는 부적합할 수 있다.

## HTTP Request Method

| Method  | Desc                               | Idempotent |
| ------- | ---------------------------------- | ---------- |
| GET     | 요청된 URI 정보 응답               | O          |
| POST    | 요청된 자원 생성                   | X          |
| PUT     | 요청된 자원 수정(자원 전체 갱신)   | O          |
| DELETE  | 요청된 자원 삭제                   | O          |
| HEAD    | 요청된 URI 정보 응답(HEAD만)       | O          |
| PATCH   | 요청된 자원 수정(해당 자원만 갱신) | X          |
| CONNECT | 프록시 기능 요청 시 사용           | X          |
| TRACE   | 루프백 메시지 호출 시 사용         | O          |
| OPTIONS | 메서드 종류 확인 시 사용           | O          |

- Idempotent

  - 한 번 수행하든, 여러 번 수행하든 결과가 같은가

- 서비스 시 지원해야할 메서드
  - GET, POST, HEAD, OPTIONS
- 보안 취약점을 야기할 수 있으므로 비활성화 필요
  - PUT(Web Shell을 통한 시스템 침투 가능(파일 업로드)), DELETE(클라이언트에서 웹 서버 파일 삭제), CONNECT(HTTP 프록시 악용), TRACE(XST 공격으로 세션 탈취)

## Cookie, Session

- Cookie
  - 클라이언트가 웹 사이트에 접속할 때 그 사이트가 사용하는 일련의 작은 기록 파일
  - Key-Value 형식의 문자열 형태로 이루어진다.
  - 서버가 클라이언트에게 전달할 때 Response Header(Cookie)에 저장하여 전달한다.
  - 쿠키는 노출되었을 때 민감 정보까지 다 노출될 수 있으므로 보안적인 측면에서 좋지 않으며, 웹 브라우저마다 지원 형식이 달라 다른 브라우저 간 공유가 불가능하다.
  - 크기 제한(4KB)이 있어 원하는 정보를 충분히 담지 못할 수 있다.
- Session

  - 쿠키의 단점 중 민감 정보 노출과 같은 단점을 보완하기 위해 나온 것으로 특정 인증 정보를 서버가 가지고 있으며, 그 값을 클라이언트에게 전달하여 키를 주고 자물쇠를 여는 방식으로 인증한다.
  - 세션은 HTTP의 장점이라고 할 수 있는 Stateless를 위반한다. 세션 저장소에 세션 ID를 저장하므로 Stateful 하게 된다.
  - 서버에 상태를 저장해야 하므로 해당 서버를 늘리고 싶을 때(Scale out) 세션 저장소가 Scale out 하기 이전 서버에 있기 때문에 또 세션 ID를 저장해야 하는 단점이 있다. 이를 최소화하기 위해 중앙 세션 저장소를 만들어 사용한다.
  - 세션 저장소에 문제가 발생하면 이미 인증된 유저도 인증이 불가능하게 되며, Stateful 하므로 http의 장점을 발휘하지 못하고 Scale out이 어려울 수 있는 점, 세션 저장소가 필수이기 때문에 이를 사용하기 위한 비용이 든다는 점, 매번 요청 시 세션 저장소를 조회해야 한다는 단점이 있다.

- Stateless
  - HTTP의 특징 중 하나로, 클라이언트와 서버 관계에서 서버가 클라이언트의 상태를 보존하지 않음을 의미한다.
  - 서버의 확장성이 높기 때문에 대량의 트래픽 발생 시에도 대처를 수월하게 할 수 있다는 장점이 있지만, 클라이언트의 요청에 상대적으로 Stateful 보다 더 많은 데이터가 소모되는 단점이 있다.
- Stateful
  - 클라이언트와 서버 관계에서 서버가 클라이언트의 상태를 보존함을 의미한다.
- Stateless와 Stateful의 이해

  - Stateful

    - 자전거 판매를 하는 서버 X / 자전거 사려는 클라이언트 A
    - ```
      A : 자전거 사려합니다
      X : 자전거 커스텀 재료를 골라주세요 (자전거를 사려한다는 것을 기억한다)

      A : 휠은 검정색, 핸들은 검정색, 바디는 흰색, 안장은 흰색으로 해주세요
      X : 배송은 어디로 해드릴까요? (자전거를 사려했다는 것을 기억하고 있다)

      A : 집으로 보내주세요
      X : 결제는 무엇으로 해드릴까요? (자전거를 사려했다는 것, 커스텀을 어떻게 했는지 알고 있다)

      A : 카드로 결제할게요
      X : 결제 완료 되었습니다. (위의 모든 사용자가 요구했던 사항을 기억하고 있다)
      ```

    - 이때, 판매 서버 X가 바뀐다면?
    - ```
      A : 자전거 사려합니다
      X : 자전거 커스텀 재료를 골라주세요

      A : 휠은 검정색, 핸들은 검정색, 바디는 흰색, 안장은 흰색으로 해주세요
      Y : 네? 어떤걸 말씀하시는거죠?

      A : 집으로 보내주세요
      Z : ?

      A : 카드로 결제할게요
      X : 네?
      ```

  - Stateless

    - 위 상황과 같은 문제를 해결하기 위해 등장하게 된다
    - 자전거 판매를 하는 서버 X, 대체 가능한 서버 Y, Z / 자전거 사려는 클라이언트 A
    - ```
      A : 자전거 사려합니다.
      X : 자전거 커스텀 재료를 골라주세요. (서버는 아무것도 기억하지 않는다)

      A : 자전거를 사려합니다. 휠은 검정색, 핸들은 검정색, 바디는 흰색, 안장은 흰색으로 해주세요.
      Y : 배송은 어디로 해드릴까요? (서버는 아무것도 기억하지 않는다)

      A : 자전거를 사려합니다. 휠은 검정색, 핸들은 검정색, 바디는 흰색, 안장은 흰색으로 해주세요. 배송은 집으로 보내주세요.
      Z : 결제는 무엇으로 해드릴까요? (서버는 아무것도 기억하지 않는다)

      A : 자전거를 사려합니다. 휠은 검정색, 핸들은 검정색, 바디는 흰색, 안장은 흰색으로 해주세요. 배송은 집으로 보내주세요. 결제는 카드로 할게요.
      Y : 결제 완료 되었습니다. (서버는 들어온 요청을 처리한다)
      ```

  - Stateless의 단점은 클라이언트가 하고자 하는 최종 목적을 위해 지나는 과정마다 점점 전달해야 하는 내용이 많아진다는 것이다.
  - 대표적으로 많이 사용되는 약속 중 HTTP는 이 무상태를 특징으로 기본적으로 가지고 있다. 특별한 일이 없다면 무상태(Stateless)를 지향해야 하며 필요한 경우에만 상태 유지(Stateful)를 해야 한다.

## Web Server Configuration

### keep-alive

연결된 socket에 in/out의 access가 마지막으로 종료된 시점부터 정의된 시간까지의 access가 없더라도 대기하는 구조이다. 즉, 정의된 시간 내에 access가 이루어진다면 계속 연결된 상태를 유지할 수 있다.

## Web Server, WAS

Apache, Nginx는 웹 서버, Tomcat은 WAS(Web Application Server)

웹 서버는 정적인 데이터를 처리하는 서버로, 이미지나 단순 html 파일과 같은 리소스를 제공하면 빠르고 안정적이다.
WAS는 동적인 데이터를 처리하는 서버로 DB와 연결되어 데이터를 주고받거나 프로그램으로 데이터 조작이 필요한 경우 WAS를 활용해야 한다.

- Static Page
  - 파일 경로 이름을 받아 일치하는 파일 콘텐츠를 반환하며, 항상 동일한 페이지를 반환한다.
- Dynamic Page
  - 인자의 내용에 맞게 동적인 콘텐츠를 반환한다.
- Web Server
  - 하드웨어
    - Web 서버가 설치되어 있는 컴퓨터
  - 소프트웨어
    - 웹 브라우저 클라이언트로부터 HTTP 요청을 받아 정적인 콘텐츠(.html, .css, .jpg 등)를 제공하는 컴퓨터 프로그램
  - WAS를 거치지 않고 정적인 콘텐츠를 제공하도록 하거나 동적인 콘텐츠 제공을 위해 클라이언트(웹 브라우저)의 요청을 WAS로 보내고 WAS가 처리한 결과를 클라이언트에게 응답하는 역할을 한다.
- WAS(Web Application Server)
  - DB 조회나 다양한 로직 처리를 요구하는 동적인 콘텐츠를 제공하기 위한 Application Server
  - Web Container 혹은 Servlet Container라고도 한다.
  - WAS = Web Server + Web Container
    - Web Server의 기능을 구조적으로 분리하여 처리하고자 하는 목적
      - 분산 트랜잭션, 보안, 쓰레드 처리 등의 기능을 처리하는 분산 환경에서 사용
      - 주로 DB 서버와 같이 수행된다.
  - 프로그램 실행 환경과 DB 접속 기능 제공
  - 여러 개의 트랜잭션(논리적인 작업 단위) 관리 기능
  - 업무를 수행하는 비즈니스 로직 수행
- Web Server와 WAS를 구분하는 이유
  - Web Server가 필요한 이유
    - 클라이언트(웹 브라우저)에 이미지(정적인 콘텐츠)를 보낼 때, html이 클라이언트로 보내질 때 함께 가는 것이 아니다.
    - 클라이언트는 html 문서를 먼저 받고, 필요한 것을 다시 서버로 요청한다.
    - Web Server를 통해 정적인 파일들은 WAS까지 가지 않고 앞단에서 빠르게 처리 가능해진다.
    - 즉, Web Server에서는 정적 콘텐츠만 처리하도록 기능을 분배하여 서버 부담을 줄인다.
  - WAS가 필요한 이유
    - 웹 페이지는 정적인 페이지, 동적인 페이지 모두 존재하는데 Web Server만 사용하는 경우 사용자의 요청 값에 대한 결괏값을 미리 만들어 놓고 서비스 해야 한다. 이렇게는 자원이 절대적으로 부족하므로 할 수 없다.
    - 따라서, WAS를 통해 요청에 맞는 데이터를 비즈니스 로직에 맞게 그때그때 결과를 만들어 제공함으로써 자원을 효율적으로 쓸 수 있다.
  - WAS만 쓰지 않는 이유
    - 기능을 분리하여 서버 부하 방지
      - 정적인 요청까지 WAS에서 처리한다면 정적 데이터 처리로 인해 서버 부하가 커지고, 이에 따라 동적인 요청의 수행 속도가 느려진다.
    - 물리적으로 분리하여 보안 강화
      - SSL에 대한 암복호화 처리에 Web Server를 사용한다.
    - 여러 대의 WAS를 연결 가능
      - Load balancing을 위해 Web Server를 사용한다.
      - 대용량 웹 애플리케이션의 경우(여러 개의 서버 사용) Web Server와 WAS를 분리하여 무중단 운영을 위한 장애 극복에 쉽게 대응할 수 있다.
    - 여러 웹 애플리케이션 서비스 가능
    - 기타
      - 접근 허용 IP 관리, 2대 이상의 서버에서의 세션 관리 등도 Web Server에서 처리하면 효율적이다.
  - 자원 이용의 효율성 및 장애 극복, 배포 및 유지보수의 편의성을 위해 Web Server와 WAS를 분리한다.

## CSRF, XSS

| \         | XSS                                                                                                                               | CSRF                                                       |
| --------- | --------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------- |
| 개요      | 악성 스크립트가 클라이언트에서 실행됨                                                                                             | 권한을 도용당한 클라이언트가 가짜 요청을 서버에 전송       |
| 공격 대상 | 클라이언트                                                                                                                        | 서버                                                       |
| 목적      | 쿠키/세션 갈취, 웹 사이트 변조 등                                                                                                 | 권한 도용                                                  |
| 방지      | <ul><li>쿠키에 중요 정보 저장X</li><li>정보 암호화</li><li>httponly on(document.cookie 막는 방법)</li><li>Secure coding</li></ul> | <ul><li>Referer 검증</li><li>Security Token 사용</li></ul> |

- CSRF(Cross-Site Request Fogery)
  - 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정 웹 사이트에 요청하게 만드는 공격 방식
  - 공격자가 사용자 PC를 감염시키거나 사이트 해킹을 통해 하는 것이 아니기 때문에 공격이 성공하려면 2가지 전제 조건을 만족시켜야 한다.
    - 위조 요청을 하는 서비스에 희생자가 로그인 상태이어야 한다.
    - 희생자는 공격자가 만든 피싱 사이트에 접속해야 한다.
- XSS(Cross-Site Scripting)
  - 악의적인 사용자가 공격하려는 사이트에 스크립트를 넣는 기법
  - Reflected XSS
    - URL Parameter에 스크립트를 넣어 서버에 저장하지 않고, 그 즉시 스크립트를 만드는 방식이다.
    - 브라우저 자체에서 차단하는 경우가 많다.
  - Stored XSS
    - 스크립트가 서버에 저장되어 실행되는 방식이다.
    - 게시판이나 댓글에 저장하여 실행될 수 있다.
- 대응 기법
  - 입출력 값 검증
    - XSS Cheat Sheet에 대한 필터 목록을 만들어 모든 Cheat Sheet에 대한 대응을 가능하도록 사전에 대비한다. XSS 필터링을 적용 후 스크립트가 실행되는지 직접 테스트 과정을 거쳐볼 수도 있다.
  - XSS 방어 라이브러리, 확장앱
    - Anti XSS 라이브러리를 제공해 주는 회사들이 많다. 이 라이브러리는 서버 단에서 추가하며, 사용자들은 각자 브라우저에서 악성 스크립트가 실행되지 않도록 확장앱을 설치하여 방어할 수 있다.
  - 웹 방화벽
    - 웹 방화벽은 웹 공격에 특화된 것으로, 다양한 Injection을 한꺼번에 방어할 수 있는 장점이 있다.
  - CORS, SOP 설정
    - CORS(Cross-Origin Resource Sharing), SOP(Same-Origin-Policy)를 통해 리소스의 Source를 제한 하는 것이 효과적인 방어 방법이 될 수 있다. 웹 서비스상 취약한 벡터에 공격 스크립트를 삽입 할 경우, 치명적인 공격을 하기 위해 스크립트를 작성하면 입력값 제한이나 기타 요인 때문에 공격 성공이 어렵다. 그러나 공격자의 서버에 위치한 스크립트를 불러 올 수 있다면 이는 상대적으로 쉬워진다. 그렇기 때문에 CORS, SOP를 활용 하여 사전에 지정된 도메인이나 범위가 아니라면 리소스를 가져올 수 없게 제한해야 한다.

## AJP

`Apache JServ Protocol`의 약자로, 아파치와 톰캣이 연동하기 위해선 AJP를 통해 서로 통신하여야 한다. AJP란 아파치가 웹 서버와 외부 서비스(톰캣 등)와 연동하기 위해 정한 규약(프로토콜)이다. 아파치는 이를 사용하여 80포트로 들어오는 요청은 자신이 받고, 이 요청 중 서블릿을 필요로 하는 요청은 톰캣에 접속하여 처리한다.

- mod_jk
  - AJP 프로토콜을 사용하여 톰캣과 연동하기 위해 만들어진 모듈
